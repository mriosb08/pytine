#!/usr/bin/python
from optparse import OptionParser
import pickle
from metrics import SetMetrics, VerbMetrics, VectorMetrics, NEMetrics
from tine import TineVN
from edistance_srl import Edistance
def main():
    parser = OptionParser(usage="usage: %prog [options]", version="%prog 1.0")
    parser.add_option("-p", "--pickle-file", action="store", dest="pickle_file"
            , help="Pickle file generated by preprocessing for extract features")
    parser.add_option("-o", "--output-file", action="store", dest="output_file"
            , help="Output file for generated features")
    parser.add_option("-t","--sim-type", action = "store", dest = "sim_type", default = "Lin"
            , help = "Similarity resource used to expand bag of words: [Lin|WordNet] default: Lin")
    parser.add_option("-u","--out-type", action = "store", dest = "out_type", default = "pickle"
            , help = "type of output file [arff|svn|pickle] default: pickle")
    (options, args) = parser.parse_args()
    if not options.pickle_file or not options.output_file:
        parser.error("wrong number of options")
    extractFeatures(options)
    return

def extractFeatures(options):

    with open(options.pickle_file, 'r') as pf:
        pairs = pickle.load(pf)
        metrics = SetMetrics()
        meteor_h = []
        meteor_t = []
        feature_values = {}
        i = 0
        if options.sim_type:
            tine = TineVN(sim_type = options.sim_type)
        else:
            tine = TineVN()
        ne = NEMetrics()
        ed = Edistance(verbose = 0)
        for pair in pairs:
            id = pair.get_id()
            value = pair.get_value()
            lemmas_text = pair.get_feature_text('lemmas')
            lemmas_hypo = pair.get_feature_hypo('lemmas')
            frames_text = pair.get_feature_text('frames')
            frames_hypo = pair.get_feature_hypo('frames')
            ne_text = pair.get_feature_text('ne')
            ne_hypo = pair.get_feature_hypo('ne')
            pos_text = pair.get_feature_text('pos')
            pos_hypo = pair.get_feature_hypo('pos')
            chunk_text = pair.get_feature_text('chunks')
            chunk_hypo = pair.get_feature_hypo('chunks')

            tokens_text = []
            tokens_hypo = []
            if options.sim_type == 'WordNet':
                tokens_text = toWN(lemmas_text, pos_text)
                tokens_hypo = toWN(lemmas_hypo, pos_hypo)
            elif options.sim_type == 'Lin':
                tokens_text = lemmas_text
                tokens_hypo = lemmas_hypo
            
            metrics.set_text(lemmas_text)
            metrics.set_hypo(lemmas_hypo)
            ne.set_pairs_text(ne_text)
            ne.set_pairs_hypo(ne_hypo)
            ne_score = ne.get_score_lin()
            cos = metrics.cosine()
            rec = metrics.get_recall()
            prec = metrics.get_precision()
            f1 = metrics.get_f1()
            bleu = metrics.bleu()
            meteor_t.append((id, lemmas_text))
            meteor_h.append((id, lemmas_hypo))
            
            tine_score = tine.get_tine_score(frames_text, tokens_text, frames_hypo, tokens_hypo)
            
            ed_score = ed.get_edistance_micai(frames_text, tokens_text, chunk_text, frames_hypo, tokens_hypo, chunk_hypo, entailment = value)
            
            feature_values.setdefault(id, {})
            feature_values[id]['cos'] = cos
            feature_values[id]['f1'] = f1
            feature_values[id]['rec'] = rec
            feature_values[id]['prec'] = prec
            feature_values[id]['bleu'] = bleu
            feature_values[id]['value'] = value
            feature_values[id]['tine'] = tine_score
            feature_values[id]['ne'] = ne_score
            feature_values[id]['ed'] = ed_score
            #if tine_score == 0:
            #   i += 1

        
        feature_values = addMeteor(feature_values, metrics, meteor_h, meteor_t)
        dumpFeatures(feature_values, options.output_file, options.out_type)
        #print 'ed 0: ', i, 'tot: ', len(pairs)

def toWN(lemmas, pos):
    return zip(lemmas, pos)


def addMeteor(feature_values, metrics, meteor_h, meteor_t):
    meteor_score = metrics.meteor_list(meteor_t, meteor_h)
    for id, score in meteor_score.items():
        if id in feature_values:
            feature_values[id]['meteor'] = score
    return feature_values

def dumpFeatures(feature_values, o_file, o_type):
    if o_type == 'pickle':
        pickle.dump(feature_values, open(o_file, "wb" ) )
    elif o_type == 'svn':
        svnDump(feature_values, o_file)
    elif o_type == 'arff':
        #TODO
        wekaDump(feature_values, o_file)

    else:
        for id, features in feature_values.items():
            print 'id:', id, '\tf: ', features
    return

def svnDump(feature_values, o_file):
    with open(o_file, 'w') as f:
        for id, features in feature_values.items():
            tmp = []
            value = ''
            id_f = 1
            for name in sorted(features.iterkeys()):
                if name == 'value':
                    if features[name] == 'TRUE':
                        value = '+1'
                    elif features[name] == 'FALSE':
                        value = '-1'
                else:
                    tmp.append('%d:%f'%(id_f, features[name]))
                    id_f += 1
            print >>f, value, ' ', ' '.join(tmp), '# id:%d\n'%id
    f.close()
    return

def wekaDump(feature_values, o_file):
    return
    #with open(o_file, 'w') as f:
    #   print >>f, '@RELATION: %s\n'%o_file
        
    #  print >>f, '@ATRRIBUTE cosine NUMERIC\n'


if __name__ == '__main__':
    main()
